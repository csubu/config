#+TITLE: Michael Fogleman's Emacs configuration
#+OPTIONS: toc:4 h:4
* Introduction
** Quotations
*** On Emacs
#+begin_quote 
Emacs outshines all other editing software in approximately the same way that the noonday sun does the stars. It is not just bigger and brighter; it simply makes everything else vanish.

-- Neal Stephenson, "[[http://www.cryptonomicon.com/beginning.html][In the Beginning was the Command Line]]"
#+end_quote

#+begin_quote
On 2 Apr 1992 in the journal Nature the discovery was reported that a giant ancient fungus had been living under the forests of Michigan for at least 1,500 years, the oldest and largest living thing on Earth. Software could get to be like that, I suppose, and Emacs, incorporating, like the fungal thallus, all the the filamentous strands of Emacs Lisp that now already thinly web the Earth, is surely a front runner. But do not be distracted by such lives.  Even the life of Emacs, like the life of that fungus, is an ephemerality; to grok life one must transcend not only thermospace but cyberspace.

-- [[http://www.eskimo.com/~seldon/dotemacs.el][Will Mengarini]]
#+end_quote
*** On Literate Programming
#+begin_quote 
Let us change our traditional attitude to the construction of programs: Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do.

The practitioner of literate programming can be regarded as an essayist, whose main concern is with exposition and excellence of style. Such an author, with thesaurus in hand, chooses the names of variables carefully and explains what each variable means. He or she strives for a program that is comprehensible because its concepts have been introduced in an order that is best for human understanding, using a mixture of formal and informal methods that reinforce each other.

-- Donald Knuth
#+end_quote

#+begin_quote 
In my experience, software created with literate programming has turned out to be significantly better than software developed in more traditional ways...

Jon Bentley probably hit the nail on the head when he once was asked why literate programming hasn’t taken the whole world by storm. He observed that a small percentage of the world’s population is good at programming, and a small percentage is good at writing; apparently I am asking everybody to be in both subsets.

Yet to me, literate programming is certainly the most important thing that came out of the TeX project. Not only has it enabled me to write and maintain programs faster and more reliably than ever before, and been one of my greatest sources of joy since the 1980s—it has actually been indispensable at times.

-- [[http://www.informit.com/articles/article.aspx?p=1193856][Donald Knuth]]
#+end_quote
* Settings
** Personal information
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Michael Fogleman"
        user-mail-address "michaelwfogleman@gmail.com")
#+END_SRC
** Enable package support
I set up packages, Melpa, and use-package bright and early so that I can make use of use-package's bind-key macro.

When I first copy this set-up into a new machine, I still have to require package, add MELPA, initialize package, and grab use-package, solarized-theme, and a couple of others (including my tid-mode) from the package archives and the internet. This could be improved, but it's not so bad.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives
               '("melpa" . "http://melpa.milkbox.net/packages/") t)
  (package-initialize)
  (require 'use-package) ;; currently you have to do up to hear and grab this manually :/
  (use-package diminish
    :ensure diminish
    :init
    (defmacro rename-modeline (package-name mode new-name)
      `(eval-after-load ,package-name
         '(defadvice ,mode (after rename-modeline activate)
            (setq mode-name ,new-name)))))
#+END_SRC
** Turn off unnecessary graphical features
*** Tool Bar
#+BEGIN_SRC emacs-lisp
  (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
#+END_SRC
*** Startup Messages
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t
        initial-scratch-message ""
        inhibit-startup-echo-area-message t)
#+END_SRC
*** Mode Line
[[http://www.lunaryorn.com/2014/07/26/make-your-emacs-mode-line-more-useful.html#understanding-mode-line-format][Sebastian Wiesner]] inspired me to slim down my mode line. 

I change the default mode-line-format variable, but comment out any variables that I eliminated, so that I can add them in later if I deem them useful.

I add in the date, time, and battery information in formats that I like.

Finally, I diminish some built-in minor modes.

#+BEGIN_SRC emacs-lisp
  (setq-default mode-line-format
                '("%e" ; print error message about full memory.
                  mode-line-front-space
                  ; mode-line-mule-info
                  ; mode-line-client
                  ; mode-line-modified
                  ; mode-line-remote
                  ; mode-line-frame-identification
                  mode-line-buffer-identification
                  "   "
                  ; mode-line-position
                  ; (vc-mode vc-mode)
                  ; "  "
                  mode-line-modes
                  "   "
                  ; mode-line-misc-info
                  display-time-string
                  "   "
                  battery-mode-line-string
                  mode-line-end-spaces))
  
  (display-time-mode 1)
  (setq display-time-format "%a %m/%d%t%R")
  (display-battery-mode 1)
  (setq battery-mode-line-format "%p%%") ; Default: "[%b%p%%]"
  
  (diminish 'isearch-mode)
#+END_SRC
** Window handling
To handle windows intelligently, I use the windmove functionality, along with some special functionality for Org where windmove is active in locations where Org Mode does not have special functions.

#+BEGIN_SRC emacs-lisp
  (windmove-default-keybindings)
  (add-hook 'org-shiftup-final-hook 'windmove-up)
  (add-hook 'org-shiftleft-final-hook 'windmove-left)
  (add-hook 'org-shiftdown-final-hook 'windmove-down)
  (add-hook 'org-shiftright-final-hook 'windmove-right)
#+END_SRC
** Backups
#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist
        `(("." . ,(expand-file-name
                   (concat user-emacs-directory "backups")))))
#+END_SRC
** Change prompts
Make yes or no prompts be y or n prompts.

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** Internet
It'd be great to get an Emacs browser going, but in the meantime:

#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program (cond ((eq system-type 'darwin) "open") 
                                         ((eq system-type 'gnu/linux) "firefox")))
  (bind-key "C-c B" 'browse-url)
#+END_SRC
** Other
*** Apropos
Let apropos commands perform more extensive searches than default. This also comes from Better Defaults.

#+BEGIN_SRC emacs-lisp
  (setq apropos-do-all t)
#+END_SRC
*** Buffer / File Warnings
Remove the warning if a buffer or file does not exist, so you can create them.

#+BEGIN_SRC emacs-lisp
  (setq confirm-nonexistent-file-or-buffer nil)
#+END_SRC
*** Ediff
The default Ediff behavior is confusing and not desirable. This fixes it.

#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC
*** Enable
Some features and settings are disabled by default; this is sane behavior for new users, but it is expected that we will disable them eventually.

#+BEGIN_SRC emacs-lisp
  (put 'narrow-to-region 'disabled nil)
  (put 'narrow-to-page 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
  (put 'erase-buffer 'disabled nil)
#+END_SRC
*** Mac Related
#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin) (set-face-attribute 'default nil :height 165))
#+END_SRC
* Key Bindings
Although keybindings are also located elsewhere, this section will aim to provide bindings that are not specific to any mode, package, or function. 

** System-specific
#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
    (setq mac-command-modifier 'meta
          mac-option-modifier 'super
          mac-control-modifier 'control
          ns-function-modifier 'hyper))
#+END_SRC
** From [[https://github.com/technomancy/better-defaults][Better Defaults]]
#+BEGIN_SRC emacs-lisp
  (bind-key "M-/" 'hippie-expand)
  (bind-key "C-x C-b" 'ibuffer)
  (bind-key "C-s" 'isearch-forward-regexp)
  (bind-key "C-r" 'isearch-backward-regexp)
  (bind-key "C-M-s" 'isearch-forward)
  (bind-key "C-M-r" 'isearch-backward)
#+END_SRC
** Lines
Enable line indenting automatically. If needed, you can disable on a mode-by-mode basis.

#+BEGIN_SRC emacs-lisp
  (bind-key "RET" 'newline-and-indent)
#+END_SRC

Make C-n insert new lines if the point is at the end of the buffer.

#+BEGIN_SRC emacs-lisp
  (setq next-line-add-newlines t)
#+END_SRC
** Movement
These keybindings for movement come from [[http://whattheemacsd.com/key-bindings.el-02.html][What the .emacs.d?]].

#+BEGIN_SRC emacs-lisp
  (bind-key "C-S-n"
            (lambda ()
              (interactive)
              (ignore-errors (next-line 5))))
  
  (bind-key "C-S-p"
            (lambda ()
              (interactive)
              (ignore-errors (previous-line 5))))
  
  (bind-key "C-S-f"
            (lambda ()
              (interactive)
              (ignore-errors (forward-char 5))))
  
  (bind-key "C-S-b"
            (lambda ()
              (interactive)
              (ignore-errors (backward-char 5))))
#+END_SRC
** Meta Binds
Since you don't need three ways to do numeric prefixes, you can [[http://endlessparentheses.com/Meta-Binds-Part-1%25253A-Drunk-in-the-Dark.html][make use of]] meta-binds instead:

#+BEGIN_SRC emacs-lisp
  (bind-key "M-9" 'sp-backward-sexp)
  (bind-key "M-0" 'sp-forward-sexp)
  (bind-key "M-1" 'delete-other-windows)
  (bind-key "M-%" 'query-replace-regexp)
  (bind-key "M-5" 'replace-regexp)
  (bind-key "M-O" 'mode-line-other-buffer)
#+END_SRC
** Copying and Killing
ejmr's [[http://ericjmritz.name/2013/06/01/snippets-from-my-personal-emacs-configuration/][snippets post]] recommends giving this advice to kill-ring-save and kill-ring, which, if no region is selected, makes C-w and M-w kill or copy the current line. 

#+BEGIN_SRC emacs-lisp
  (defadvice kill-ring-save (before slick-copy activate compile)
    "When called interactively with no active region, copy a single line instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (message "Copied line")
       (list (line-beginning-position)
             (line-beginning-position 2)))))
  
  (defadvice kill-region (before slick-cut activate compile)
    "When called interactively with no active region, kill a single line instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (list (line-beginning-position)
             (line-beginning-position 2)))))
#+END_SRC
** backward-kill-line
This binding comes from [[http://emacsredux.com/blog/2013/04/08/kill-line-backward/][Emacs Redux]]. Note that we don't need a new function, just an anonymous function.

#+BEGIN_SRC emacs-lisp
  (bind-key "C-<backspace>" (lambda ()
                              (interactive)
                              (kill-line 0)
                              (indent-according-to-mode)))
#+END_SRC
** Sentence and Paragraph Commands
By default, sentence-end-double-space is set to t. That convention may be programatically convenient, but that's not how I write. I want to be able to write normal sentences, but still be able to fill normally. Let to the rescue!

#+BEGIN_SRC emacs-lisp
  (defadvice forward-sentence (around real-forward)
    "Consider a sentence to have one space at the end."
    (let ((sentence-end-double-space nil))
      ad-do-it))
  
  (defadvice backward-sentence (around real-backward)
    "Consider a sentence to have one space at the end."
    (let ((sentence-end-double-space nil))
      ad-do-it))
  
  (defadvice kill-sentence (around real-kill)
    "Consider a sentence to have one space at the end."
    (let ((sentence-end-double-space nil))
      ad-do-it))
  
  (ad-activate 'forward-sentence)
  (ad-activate 'backward-sentence)
  (ad-activate 'kill-sentence)
#+END_SRC

A slightly less tricky matter is the default binding of backward- and forward-paragraph, which are at the inconvenient M-{ and M-}. This makes a bit more sense, no?

#+BEGIN_SRC emacs-lisp
  (bind-key "M-A" 'backward-paragraph)
  (bind-key "M-E" 'forward-paragraph)
#+END_SRC 
** [[http://endlessparentheses.com/the-toggle-map-and-wizardry.html][Toggle Map]]
Augmented by a post on [[http://irreal.org/blog/?p%3D2830][Irreal]]. Some keys on the toggle map are elsewhere in this config.

#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'toggle-map)
  (bind-key "C-x t" 'toggle-map)
  (bind-keys :map toggle-map
             ("l" . linum-mode)
             ("o" . org-mode)
             ("s" . smartparens-mode)
             ("t" . text-mode)
             ("w" . whitespace-mode))
#+END_SRC
** [[http://endlessparentheses.com/launcher-keymap-for-standalone-features.html][Launcher Map]]
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'launcher-map)
  (bind-key "C-x l" 'launcher-map)
  (bind-keys :map launcher-map
             ("a" . ansi-term)
             ("c" . calc)
             ("d" . ediff-buffers)
             ("e" . eshell)
             ("h" . man)
             ("p" . list-packages)
             ("P" . proced))
#+END_SRC
* System
All of my packages for interacting with my laptop.
** Shell
#+BEGIN_SRC emacs-lisp
  (use-package shell
    :bind ("<f1>" . shell)
    :init
    (dirtrack-mode)
    (setq explicit-shell-file-name (cond ((eq system-type 'darwin) "/bin/bash")
                                         ((eq system-type 'gnu/linux) "/usr/bin/bash")))
    (when (eq system-type 'darwin)
      (use-package exec-path-from-shell
        :init
        (exec-path-from-shell-initialize))))
#+END_SRC
** Dired
#+BEGIN_SRC emacs-lisp
  (use-package dired
    :bind ("<f2>" . dired)
    :init
    (use-package dired-x)  ; enables dired-jump, C-x C-j
    :config
    (put 'dired-find-alternate-file 'disabled nil)
    (setq dired-dwim-target t
          dired-recursive-deletes 'always
          dired-recursive-copies 'always)
    (bind-keys :map dired-mode-map
               ("<return>" . dired-find-alternate-file)
               ("^" . (lambda () (interactive) (find-alternate-file "..")))
               ("'" . wdired-change-to-wdired-mode))
    (use-package dired-details
      :ensure dired-details
      :init
      (dired-details-install))
    (use-package dired-subtree
      :ensure dired-subtree
      :init
      (bind-keys :map dired-mode-map
                 :prefix "C-,"
                 :prefix-map dired-subtree-map
                 :prefix-docstring "Dired subtree map."
                 ("C-i" . dired-subtree-insert)
                 ("C-/" . dired-subtree-apply-filter)
                 ("C-k" . dired-subtree-remove)
                 ("C-n" . dired-subtree-next-sibling)
                 ("C-p" . dired-subtree-previous-sibling)
                 ("C-u" . dired-subtree-up)
                 ("C-d" . dired-subtree-down)
                 ("C-a" . dired-subtree-beginning)
                 ("C-e" . dired-subtree-end)
                 ("m" . dired-subtree-mark-subtree)
                 ("u" . dired-subtree-unmark-subtree)
                 ("C-o C-f" . dired-subtree-only-this-file)
                 ("C-o C-d" . dired-subtree-only-this-directory))))
#+END_SRC

Some of these suggestions are adapted from Xah Lee's [[http://ergoemacs.org/emacs/emacs_dired_tips.html][article on Dired]]. dired-find-alternate-file, which is bound to a, is disabled by default. <return> was previously dired-advertised-find-file, and ^ was previously dired-up-directory. Relatedly, I re-bind 'q' to my kill-this-buffer function below.

Dired-details lets me show or hide the details with ) and (, respectively. If, for some reason, it becomes hard to remember this, dired-details+ makes the parentheses interchangeable.
** Ag
#+BEGIN_SRC emacs-lisp
  (use-package ag
    :ensure ag
    :init
    (use-package wgrep
      :ensure wgrep)
    (use-package wgrep-ag
      :ensure wgrep-ag)
    :config
    (setq ag-highlight-search t))
#+END_SRC
* Emacs
These are helper packages that make Emacs even more awesome.
** IDO
[[http://www.masteringemacs.org/articles/2010/10/10/introduction-to-ido-mode/][IDO]] lets you interactively do things with files and buffers.

One key component below is ido-vertical-mode, which makes ido much more attractive.

#+BEGIN_SRC emacs-lisp
  (setq ido-enable-flex-matching t
        ido-everywhere t
        ido-use-faces nil ;; disable ido faces to see flx highlights.
        ido-create-new-buffer 'always
        ido-use-filename-at-point 'guess)
  (ido-mode 1)
  (bind-key "C-x C-d" 'ido-dired)
  (use-package ido-vertical-mode
    :ensure ido-vertical-mode
    :init
    (ido-vertical-mode))
  (use-package ido-ubiquitous
    :ensure ido-ubiquitous
    :init
    (ido-ubiquitous-mode 1))
  (use-package flx-ido
    :ensure flx-ido
    :init
    (setq flx-ido-threshold 1000)
    (flx-ido-mode 1))
  (use-package idomenu
    :ensure idomenu
    :bind ("M-i" . idomenu))
#+END_SRC

Note that there are certain program specific settings for IDO, which are not in this section:

*** Smex
*** Org-Mode
*** ido-recentf-open function
** Smex
Smex (Smart M-X) implements IDO functionality for the M-X window.

#+BEGIN_SRC emacs-lisp
  (use-package smex
    :ensure smex
    :bind (("C-x C-m" . smex)
           ("C-c C-c M-x" . execute-extended-command))
    :init
    (unbind-key "M-x")
    (unbind-key "<menu>")
    (smex-initialize))
#+END_SRC
** Company Mode
#+BEGIN_SRC emacs-lisp
  (use-package company-mode
    :ensure company
    :bind ("C-." . company-complete)
    :init
    (global-company-mode 1)
    (diminish 'company-mode)
    (bind-keys :map company-active-map
               ("C-n" . company-select-next)
               ("C-p" . company-select-previous)
               ("C-d" . company-show-doc-buffer)
               ("<tab>" . company-complete)))
#+END_SRC
** Ace Jump Mode
#+BEGIN_SRC emacs-lisp
  (use-package ace-jump-mode
    :ensure ace-jump-mode
    :bind ("M-SPC" . ace-jump-mode)
    :init
    (use-package ace-jump-buffer
      :ensure ace-jump-buffer)
    (use-package ace-link
      :ensure ace-link
      :init
      (ace-link-setup-default))
    (use-package ace-jump-zap
      :ensure ace-jump-zap
      :bind (("M-z" . ace-jump-zap-to-char-dwim)
             ("M-Z" . ace-jump-zap-up-to-char-dwim))
      :init
      (bind-keys :prefix-map ace-jump-map
                 :prefix "C-c j"
                 ("c" . ace-jump-char-mode)
                 ("l" . ace-jump-line-mode)
                 ("w" . ace-jump-word-mode)
                 ("b" . ace-jump-buffer)
                 ("o" . ace-jump-buffer-other-window)
                 ("z" . ace-jump-zap-to-char)
                 ("Z" . ace-jump-zap-up-to-char))))
  
  (bind-key "C-x SPC" 'just-one-space)
#+END_SRC
** Expand Region
Configured like Magnars in Emacs Rocks, [[http://emacsrocks.com/e09.html][Episode 09]].

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure expand-region
    :bind (("C-@" . er/expand-region)
           ("C-=" . er/expand-region)))
  (pending-delete-mode t)
#+END_SRC
** Multiple Cursors
You've got to admit, [[http://emacsrocks.com/e13.html][Emacs Rocks]]. Thanks for the [[https://dl.dropboxusercontent.com/u/3968124/sacha-emacs.html#sec-1-3-3-1][code]], Sacha.

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure multiple-cursors
    :bind 
     (("C->" . mc/mark-next-like-this)
      ("C-<" . mc/mark-previous-like-this)
      ("C-*" . mc/mark-all-like-this)))
#+END_SRC EMACS-LISP
** Hungry Delete Mode
Via [[http://endlessparentheses.com/hungry-delete-mode.html?source%3Drss][Endless Parentheses]].
#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :ensure hungry-delete
    :init
    (global-hungry-delete-mode))
#+END_SRC
** Kill Ring
The word "kill" might be antiquated, idiosyncratic jargon, but it's great that Emacs keeps track of what's been killed. The package "Browse Kill Ring" is crucial to making that functionality visible and usable.

#+BEGIN_SRC emacs-lisp
  (use-package browse-kill-ring
    :ensure browse-kill-ring
    :bind ("C-x C-y" . browse-kill-ring)
    :config
    (setq browse-kill-ring-quit-action 'kill-and-delete-window))
#+END_SRC
** Recent Files
Recent files is a minor mode that keeps track of which files you're using, and provides it in some handy places.

I also rebind the find-file-read-only with ido-recent-files functionality, which I took from [[http://www.masteringemacs.org/articles/2011/01/27/find-files-faster-recent-files-package/][Mastering Emacs]].

#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :init
    (recentf-mode t)
    (setq recentf-max-saved-items 100)
    (defun ido-recentf-open ()
      "Use `ido-completing-read' to \\[find-file] a recent file"
      (interactive)
      (if (find-file (ido-completing-read "Find recent file: " recentf-list))
          (message "Opening file...")
        (message "Aborting")))
    :bind ("C-x C-r" . ido-recentf-open))
#+END_SRC
** Save Place
This comes from [[http://whattheemacsd.com/init.el-03.html][Magnars]].

#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :init
    (setq-default save-place t)
    (setq save-place-file (expand-file-name ".places" user-emacs-directory)))
#+END_SRC
** Key Chord mode
#+BEGIN_SRC emacs-lisp
  (use-package key-chord
    :ensure key-chord
    :init
    (progn 
      (setq key-chord-two-keys-delay .015
            key-chord-one-key-delay .020)
      (key-chord-mode 1)
      (key-chord-define-global "cg" 'undo)
      (key-chord-define-global "yp" 'other-window)
      (key-chord-define-global ";0" 'delete-window)
      (key-chord-define-global ";1" 'delete-other-windows)
      (key-chord-define-global ";2" 'split-window-below)
      (key-chord-define-global ";3"  'split-window-right)
      (key-chord-define-global ",." 'beginning-of-buffer)
      (key-chord-define-global ".p" 'end-of-buffer)
      (key-chord-define-global "jw" 'ace-jump-word-mode)
      (key-chord-define-global "jc" 'ace-jump-char-mode)
      (key-chord-define-global "jl" 'ace-jump-line-mode)
      (key-chord-define-global "jb" 'ace-jump-buffer)
      (key-chord-define-global "jo" 'ace-jump-buffer-other-window)
      (key-chord-define-global "'l" 'ido-switch-buffer)
      (key-chord-define-global "'-" 'smex)
      (key-chord-define-global ",r" 'find-file)
      (key-chord-define-global ".c" 'ido-dired)
      (key-chord-define-global "0r" ")")
      (key-chord-define-global "1'" "!")
      (key-chord-define-global "2," "@")
      (key-chord-define-global "3." "#")
      (key-chord-define-global "4p" "$")
      (key-chord-define-global "5y" "%")
      (key-chord-define-global "6y" "^")
      (key-chord-define-global "7f" "&")
      (key-chord-define-global "8g" "*")
      (key-chord-define-global "9c" "(")
      (key-chord-define-global "-l" "_")
      (key-chord-define emacs-lisp-mode-map "7f" "&optional ")))
#+END_SRC
** Golden Ratio
#+BEGIN_SRC emacs-lisp
  (use-package golden-ratio
    :ensure golden-ratio
    :diminish golden-ratio-mode
    :init
    (golden-ratio-mode 1))
#+END_SRC
* Social
It initially seemed kind of crazy to me to do these things in Emacs, but since they are text-heavy, it ultimately makes a lot of sense.
** Email (mu4e)
I am currently using mu4e, which was indeed pretty easy to set up. I use a stock Emacs package, smptmail, to send mail. It plugs into the gnutls command line utilities, which my Arch machine has installed already.

I also have queuing set up, so that I can still "send" emails without Internet access. Once this is enabled, you can see some new options in the main view, to toggle online/offline [m], and to send queued mail [f].

The folder /home/user/Maildir/queue/ needs to be created with the command "mu mkdir." After that, run "touch ~/Maildir/queue/.noindex" to make sure mu doesn't index this folder.

Messages that Emacs cannot read can be read in the browser with the "aV" shortcut.

#+BEGIN_SRC emacs-lisp
  (use-package mu4e
    :if (eq system-type 'gnu/linux)
    :load-path "/usr/share/emacs/site-lisp/mu4e/"
    :init
    (setq mu4e-maildir "~/Maildir"
          mu4e-drafts-folder "/Gmail/[Gmail].Drafts"
          mu4e-sent-folder   "/Gmail/[Gmail].Sent Mail"
          mu4e-trash-folder  "/Gmail/[Gmail].Trash"
          mu4e-get-mail-command "offlineimap"
          mu4e-update-interval 1800
          mu4e-maildir-shortcuts
          '( ("/Gmail/INBOX"               . ?i)
             ("/Gmail/Correspondence"      . ?c)
             ("/Gmail/[Gmail].Sent Mail"   . ?s)
             ("/Gmail/[Gmail].Trash"       . ?t)
             ("/Gmail/[Gmail].All Mail"    . ?a))
          mu4e-headers-skip-duplicates t
          mu4e-view-show-images t
          mu4e-view-image-max-width 800
          message-signature "MWF"
          mu4e-sent-messages-behavior 'delete
          message-kill-buffer-on-exit t
          mu4e-headers-skip-duplicates t)
    (use-package smtpmail
      :init
      (setq message-send-mail-function 'smtpmail-send-it
            smtpmail-stream-type 'starttls
            smtpmail-default-smtp-server "smtp.gmail.com"
            smtpmail-smtp-server "smtp.gmail.com"
            smtpmail-smtp-service 587
            smtpmail-queue-mail  nil
            smtpmail-queue-dir  "/home/michael/Maildir/queue/cur"))
    :bind ("C-c m" . mu4e)
    :config
    (add-to-list 'mu4e-view-actions
                 '("ViewInBrowser" . mu4e-action-view-in-browser) t)
    (add-hook 'mu4e-compose-mode-hook 'turn-on-orgstruct)
    (add-hook 'mu4e-compose-mode-hook 'auto-fill-mode))
#+END_SRC
** IRC (ERC)
#+BEGIN_SRC emacs-lisp
  (use-package erc
    :ensure erc
    :config
    (setq erc-autojoin-channels-alist '(("freenode.net"
                                         "#emacs"))
          erc-server "irc.freenode.net"
          erc-nick "mwfogleman"
          erc-fill-function 'erc-fill-static))
#+END_SRC
** Feeds (Elfeed)
#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :ensure elfeed
    :bind ("C-c f" . elfeed)
    :config
    (setq elfeed-feeds
          '("http://cmvanschaik.blogspot.com/feeds/posts/default"
            "http://chazaqinbenin.blogspot.com/feeds/posts/default?alt=rss"
            "http://exaequali.blogspot.com/feeds/posts/default?alt=rss"
            "http://garyborjesson.wordpress.com/feed/"
            "http://planet.clojure.in/atom.xml"
            "http://planet.emacsen.org/atom.xml"
            "http://www.techmeme.com/index.xml"
            "http://www.daemonology.net/hn-daily/index.rss"
            "http://feeds.arstechnica.com/arstechnica/BAaf"
            "https://planet.archlinux.org/rss20.xml"
            "http://lifehacker.com/tag/highlights/index.xml"
            "http://shinzenyoung.blogspot.com/feeds/posts/default?alt=rss"
            "http://www.eff.org/rss/updates.xml"
            "http://www.democracynow.org/democracynow.rss"
            "http://www.economist.com/rss/the_world_this_week_rss.xml"))
    (bind-keys :map elfeed-search-mode-map
               ("?" . describe-mode)
               ("q" . kill-this-buffer)))
#+END_SRC
** Twitter (Twittering)
#+BEGIN_SRC emacs-lisp
  (use-package twittering-mode
    :ensure twittering-mode
    :bind ("C-c t" . twit)
    :config
    (bind-keys :map twittering-mode-map
               ("?" . describe-mode)
               ("@" . twittering-reply-to-user)
               ("F" . twittering-follow))
    (setq twittering-use-master-password t
          twittering-icon-mode t
          twittering-use-icon-storage t))
#+END_SRC
* Development
I had coded here and there before using Emacs, but it made me fall in love with programming! Here are language-specific (largely Lisps) or development-related packages.

** Clojure
*** Clojure Mode
#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode
    :ensure clojure-mode
    :init
    (add-to-list 'auto-mode-alist '("\\.edn$" . clojure-mode))
    (add-to-list 'auto-mode-alist '("\\.cljx\\'" . clojure-mode))
    (add-to-list 'auto-mode-alist '("\\.cljs$" . clojure-mode))
    :config
    (rename-modeline "clojure-mode" clojure-mode "λ")
    (use-package align-cljlet
      :ensure align-cljlet
      :bind ("<menu> a a" . align-cljlet)))
#+END_SRC
*** Clojure Refactor
#+BEGIN_SRC emacs-lisp
  (use-package clj-refactor
    :ensure clj-refactor
    :init
    (add-hook 'clojure-mode-hook (lambda () (clj-refactor-mode 1)))
    :config
    (cljr-add-keybindings-with-prefix "<menu>"))
#+END_SRC
*** CIDER
The function "cider-interactive-eval" comes from [[http://blog.jenkster.com/2013/12/a-cider-excursion.html][A CIDER Excursion]].

#+BEGIN_SRC emacs-lisp
  (use-package cider
    :ensure cider
    :config
    (setq nrepl-hide-special-buffers t
          nrepl-popup-stacktraces-in-repl t
          nrepl-history-file "~/.emacs.d/nrepl-history"
          cider-mode-line " CIDER"
          cider-repl-display-in-current-window t)
    (defun cider-namespace-refresh ()
      (interactive)
      (cider-interactive-eval
       "(require 'clojure.tools.namespace.repl)
    (clojure.tools.namespace.repl/refresh)"))
    
    (bind-key "M-r" 'cider-namespace-refresh cider-repl-mode-map))
#+END_SRC
*** Clojure Cookbook
I've been reading the [[https://github.com/clojure-cookbook/clojure-cookbook][Clojure Cookbook]] in Emacs with AsciiDoc mode. 

There are a lot of short chapters, so I whipped up this Elisp to switch between them.

#+BEGIN_SRC emacs-lisp
  (defun increment-clojure-cookbook ()
    "When reading the Clojure cookbook, find the next section, and close the buffer."
    (interactive)
    (let* ((cur (buffer-name))
           (split-cur (split-string cur "[-_]"))
           (chap (car split-cur))
           (rec (car (cdr split-cur)))
           (rec-num (string-to-number rec))
           (next-rec-num (1+ rec-num))
           (next-rec-s (number-to-string next-rec-num))
           (next-rec (if (< next-rec-num 10)
                         (concat "0" next-rec-s)
                       next-rec-s))
           (target (file-name-completion (concat chap "-" next-rec) "")))
      (progn 
        (if (equal target nil)
            (dired (file-name-directory (buffer-file-name)))
          (find-file target))
        (kill-buffer cur))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package adoc-mode
    :ensure adoc-mode
    :bind (("M-+" . increment-clojure-cookbook))
    :init
    (add-to-list 'auto-mode-alist '("\\.asciidoc\\'" . adoc-mode))
    (add-hook 'adoc-mode-hook 'cider-mode))
#+END_SRC
** Common Lisp
"Take this REPL, brother, and may it serve you well."

#+BEGIN_SRC emacs-lisp
  (use-package slime-autoloads
    :disabled t)
  (use-package slime
    :disabled t
    :load-path "/usr/share/emacs/site-lisp/slime/"
    :init
    (slime-setup)
    (setq inferior-lisp-program "/usr/bin/sbcl")
    (setq common-lisp-hyperspec-root "file:///home/michael/ebooks/docs/HyperSpec/")
    (add-to-list 'slime-contribs 'slime-fancy))
#+END_SRC
** Emacs Lisp
*** Elisp-Slime-Nav
#+BEGIN_SRC emacs-lisp
  (use-package elisp-slime-nav
    :ensure elisp-slime-nav
    :diminish elisp-slime-nav-mode
    :init
    (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
      (add-hook hook 'elisp-slime-nav-mode)))
#+END_SRC
*** Eldoc
When in emacs-lisp-mode, display the argument list for the current function. I liked this functionality in SLIME; glad Emacs has it too. Thanks for the tip and code, Sacha.

#+BEGIN_SRC emacs-lisp
  (autoload 'turn-on-eldoc-mode "eldoc" nil t)
  (diminish 'eldoc-mode)
  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
#+END_SRC
** Flycheck
Flycheck presents a handsome and usable interface for [[http://endlessparentheses.com/Checkdoc%25252C-Package-Developing%25252C-and-Cakes.html][checkdoc]], amongst other things.
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure flycheck
    :init
    (global-flycheck-mode))
#+END_SRC
** Magit
This code from [[http://whattheemacsd.com/setup-magit.el-01.html][Magnars]] opens magit-status in one frame, and then restores the old window configuration when you quit.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure magit
    :diminish magit-auto-revert-mode
    :bind (("C-x g" . magit-status)
           ("C-c g" . magit-status))
    :config
    (setq magit-use-overlays nil)
    (defadvice magit-status (around magit-fullscreen activate)
      (window-configuration-to-register :magit-fullscreen)
      ad-do-it
      (delete-other-windows))
  
    (defun magit-quit-session ()
      "Restores the previous window configuration and kills the magit buffer"
      (interactive)
      (kill-buffer)
      (jump-to-register :magit-fullscreen))
  
    (bind-keys :map magit-status-mode-map
               ("q" . magit-quit-session)))
#+END_SRC
** smartparens
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure smartparens
    :diminish smartparens-mode
    :bind
    (("C-M-f" . sp-forward-sexp)
     ("C-M-b" . sp-backward-sexp)
     ("C-M-d" . sp-down-sexp)
     ("C-M-a" . sp-backward-down-sexp)
     ("C-S-a" . sp-beginning-of-sexp)
     ("C-S-d" . sp-end-of-sexp)
     ("C-M-e" . sp-up-sexp)
     ("C-M-u" . sp-backward-up-sexp)
     ("C-M-t" . sp-transpose-sexp)
     ("C-M-n" . sp-next-sexp)
     ("C-M-p" . sp-previous-sexp)
     ("C-M-k" . sp-kill-sexp)
     ("C-M-w" . sp-copy-sexp)
     ("M-<delete>" . sp-unwrap-sexp)
     ("M-S-<backspace>" . sp-backward-unwrap-sexp)
     ("C-<right>" . sp-forward-slurp-sexp)
     ("C-<left>" . sp-forward-barf-sexp)
     ("C-M-<left>" . sp-backward-slurp-sexp)
     ("C-M-<right>" . sp-backward-barf-sexp)
     ("M-D" . sp-splice-sexp)
     ("C-M-<delete>" . sp-splice-sexp-killing-forward)
     ("C-M-<backspace>" . sp-splice-sexp-killing-backward)
     ("C-M-S-<backspace>" . sp-splice-sexp-killing-around)
     ("C-]" . sp-select-next-thing-exchange)
     ("C-<left_bracket>" . sp-select-previous-thing)
     ("C-M-]" . sp-select-next-thing)
     ("M-F" . sp-forward-symbol)
     ("M-B" . sp-backward-symbol)
     ("H-t" . sp-prefix-tag-object)
     ("H-p" . sp-prefix-pair-object)
     ("H-s c" . sp-convolute-sexp)
     ("H-s a" . sp-absorb-sexp)
     ("H-s e" . sp-emit-sexp)
     ("H-s p" . sp-add-to-previous-sexp)
     ("H-s n" . sp-add-to-next-sexp)
     ("H-s j" . sp-join-sexp)
     ("H-s s" . sp-split-sexp))
    :init
    (smartparens-global-mode t)
    (show-smartparens-global-mode t)
    (use-package smartparens-config)
    (use-package rainbow-delimiters
      :ensure rainbow-delimiters
      :init
      (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)))
#+END_SRC
** Projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure projectile
    :bind ("M-p" . projectile-find-file)
    :diminish projectile-mode
    :init
    (projectile-global-mode)
    (setq projectile-enable-caching t))
#+END_SRC
** linum-relative
When I toggle line-mode, I want to use relative line-numbers, à la mi amigo Ben. As he points out, the symbol linum-relative-current-symbol makes linum-relative use the absolute line number for the current line.

#+BEGIN_SRC emacs-lisp
  (use-package linum-relative
    :ensure linum-relative
    :init
    (setq linum-format 'linum-relative)
    :config
    (setq linum-relative-current-symbol ""))
#+END_SRC
** comment-dwim-2
#+BEGIN_SRC emacs-lisp
  (bind-key "M-;" 'comment-dwim-2)
#+END_SRC

* Words and Numbers
"GNU Office Suite Pro Edition," coming to a cubicle near you!
** Org Mode
*** Quotations
#+begin_quote
Org-mode does outlining, note-taking, hyperlinks, spreadsheets, TODO lists, project planning, GTD, HTML and LaTeX authoring, all with plain text files in Emacs.

-- [[http://article.gmane.org/gmane.emacs.orgmode/6224][Carsten Dominik]]
#+end_quote

#+begin_quote
If I hated everything about Emacs, I would still use it for org-mode.

-- [[http://orgmode.org/worg/org-quotes.html][Avdi]] on Twitter
#+end_quote

#+begin_quote
...for all intents and purposes, Org-mode *is* [[http://www.taskpaper.com/][Taskpaper]]!

-- [[http://article.gmane.org/gmane.emacs.orgmode/6224][Carsten Dominik]]
#+end_quote
*** Configuration
I use the stock package of org-mode as the default major mode.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :init
    (setq default-major-mode 'org-mode
          org-directory "~/org/"
          org-log-done t
          org-startup-indented t
          org-agenda-inhibit-startup nil
          org-startup-truncated nil
          org-completion-use-ido t
          org-agenda-start-on-weekday nil
          org-refile-targets (quote ((nil :maxlevel . 9)
                                     (org-agenda-files :maxlevel . 9)))
          org-refile-use-outline-path t
          org-default-notes-file (concat org-directory "notes.org")
          org-goto-max-level 10
          org-imenu-depth 5
          org-goto-interface 'outline-path-completion
          org-outline-path-complete-in-steps nil
          org-use-speed-commands t
          org-src-fontify-natively t
          org-lowest-priority 68
          org-default-priority 68
          org-agenda-files (quote ("~/org/tech.org"
                                   "~/org/meditation.org"
                                   "~/org/work.org"
                                   "~/org/money.org"
                                   "~/org/readwrite.org"
                                   "~/org/personal.org"
                                   "~/org/todo.org"
                                   "~/org/notes.org"))
          org-tag-alist '(("@email" . ?e) ("@phone" . ?p) ("@laptop" . ?l))
          org-capture-templates
          '(("a" "Arch Log" plain (file+datetree "~/org/archlog.org")
             "%?\n")
            ("c" "Conversation" entry (file+datetree "~/org/conversations.org")
             "* %?\n")
            ("g" "Gratitude Journal" entry (file+datetree "~/org/gratitude.org")
             "* I am grateful for: \n** %?")
            ("n" "Note" entry (file "~/org/notes.org")
             "* %?\n")
            ("s" "Spark" entry (file+datetree "~/org/spark.org")
             "* %?")
            ("j" "Journal" entry (file+datetree "~/org/journal.org.gpg")
             "* %?")
            ("t" "Todo" entry (file "~/org/todo.org")
             "* TODO %?\n"))
          org-file-apps
          '((auto-mode . emacs)
            ("\\.mm\\'" . default)
            ("\\.x?html?\\'" . "firefox %s")
            ("\\.pdf\\'" . "evince %s")))
    (unbind-key "C-c [")
    (unbind-key "C-c ]")
    (add-to-list 'org-structure-template-alist '("g" "# -*- mode:org; epa-file-encrypt-to: (\"michaelwfogleman@gmail.com\") -*-"))
    (add-hook 'org-shiftup-final-hook 'windmove-up)
    (add-hook 'org-shiftleft-final-hook 'windmove-left)
    (add-hook 'org-shiftdown-final-hook 'windmove-down)
    (add-hook 'org-shiftright-final-hook 'windmove-right))
#+END_SRC
My settings for capture were some of my first Elisp :) I did need, and still need, the help of the  [[http://orgmode.org/manual/Capture-templates.html#Capture-templates][Org-Mode manual]], of course.

I use org-struct in mu4e. See above.
*** Bindings
#+BEGIN_SRC emacs-lisp
  (bind-key "C-c l" 'org-store-link)
  (bind-key "C-c c" 'org-capture)
  (bind-key "C-c a" 'org-agenda)
  (bind-key "C-c b" 'org-iswitchb)
  (bind-key "C-c M-k" 'org-cut-subtree)
  (add-to-list 'org-speed-commands-user '("k" org-cut-subtree))
  (add-to-list 'org-speed-commands-user '("d" org-down-element))
#+END_SRC
** TiddlyWiki
I edit [[http://tiddlywiki.com/][TiddlyWiki]]5 .tid files in Emacs using my [[https://github.com/mwfogleman/tid-mode][tid-mode]] major mode. I create and bind functions to open the TiddlyWiki in Dired and the browser.

#+BEGIN_SRC emacs-lisp
  (use-package tid-mode
    :load-path "site-lisp/tid-mode/"
    :init
    (defun open-wiki ()
      "Opens my TiddlyWiki directory."
      (interactive)
      (dired "~/Dropbox/wiki/tiddlers/"))
    (defun browse-wiki ()
      "Opens my TiddlyWiki in my browser."
      (interactive)
      (browse-url "127.0.0.1:8080/"))
    (bind-key "C-c w" 'open-wiki)
    (bind-key "C-c W" 'browse-wiki))
#+END_SRC
** Calc
#+BEGIN_SRC emacs-lisp
  (use-package calc
    :config
    (setq calc-display-trail ()))
#+END_SRC
** Gnuplot
#+BEGIN_SRC emacs-lisp
  (use-package gnuplot
    :if (eq system-type 'gnu/linux)
    :load-path "/usr/bin/gnuplot"
    :init
    (autoload 'gnuplot-mode "gnuplot" "gnuplot major mode" t)
    (autoload 'gnuplot-make-buffer "gnuplot" "open a buffer in gnuplot mode" t)
    (add-to-list 'auto-mode-alist '("\\.gp$" . gnuplot-mode)))
#+END_SRC
* Functions
** Emacs Configuration File
This function and the corresponding keybinding allows me to rapidly access my configuration. They are adapted from Bozhidar Batsov's [[http://emacsredux.com/blog/2013/05/18/instant-access-to-init-dot-el/][post on Emacs Redux]].

I use mwf-init-file rather than user-init-file, because I edit the config file in a Git repo.

#+BEGIN_SRC emacs-lisp
  (defun find-init-file ()
    "Edit my init file in another window."
    (interactive)
    (let ((mwf-init-file "~/src/config/home/.emacs.d/michael.org"))
      (find-file mwf-init-file)))
  
  (bind-key "C-c I" 'find-init-file)
#+END_SRC

Relatedly, I often want to reload my init-file. This will actually use the system-wide user-init-file variable.

#+BEGIN_SRC emacs-lisp
  (defun reload-init-file ()
    "Reload my init file."
    (interactive)
    (load-file user-init-file))
  
  (bind-key "C-c M-l" 'reload-init-file)
#+END_SRC
** Keep In Touch
I use mi amigo [[https://github.com/benpence/][Ben]]'s [[https://github.com/benpence/keepintouch][Keep In Touch]] program. This re-implements some of the command line utility's functionality in Elisp.

#+BEGIN_SRC emacs-lisp
  (setq keepintouch-datafile "~/Dropbox/keepintouch.data")
  
  (defun keptintouch (arg)
    "Request a contact in a keepintouch.data file, and update their last
    contacted date (either today, or, if a prefix is supplied, a user-supplied date.)"
    (interactive "P")
    (let ((contact (read-string "Who did you contact? "))
          (date (if (equal arg nil)
                    (format-time-string "%Y/%m/%d")
                  (read-string "When did you contact them? (year/month/date): "))))
      (keptintouch-contact date)))
  
  (defun keptintouch-contact (date)
    "Navigates the keepintouch.data file."
    (save-excursion
      (find-file keepintouch-datafile)
      (goto-char (point-min))
      (search-forward contact)
      (forward-line -1)
      (beginning-of-line)
      (kill-line)
      (insert date)
      (save-buffer)
      (switch-to-buffer (other-buffer))
      (kill-buffer (other-buffer)))
    (message "%s was contacted." contact))
  
  (bind-key "C-c k" 'keptintouch)
#+END_SRC
** Buffer Management
*** Open Org Agenda
This function opens the agenda in full screen.

#+BEGIN_SRC emacs-lisp
  (defun open-agenda ()
    "Opens the org-agenda."
    (interactive)
    (let ((agenda "*Org Agenda*"))
      (if (equal (get-buffer agenda) nil)
          (org-agenda-list)
        (unless (equal (buffer-name (current-buffer)) agenda)
          (switch-to-buffer agenda))
        (org-agenda-redo t)
        (beginning-of-buffer)))
    (delete-other-windows))
  
  (bind-key "<f5>" 'open-agenda)
#+END_SRC
*** Kill This Buffer
#+BEGIN_SRC emacs-lisp
  (defun kill-this-buffer ()
    (interactive)
    (kill-buffer (current-buffer)))
  
  (bind-key "C-x C-k" 'kill-this-buffer)
#+END_SRC

By default, pressing 'q' in either Dired or package-menu runs quit-window, which quits the window and buries its buffer. I'd prefer the buffer to close.

#+BEGIN_SRC emacs-lisp
  (bind-keys :map dired-mode-map
             ("q" . kill-this-buffer))
  
  (bind-keys :map package-menu-mode-map
             ("q" . kill-this-buffer))
#+END_SRC
*** Kill All Other Buffers
#+BEGIN_SRC emacs-lisp
  (defun kill-other-buffers ()
     "Kill all other buffers."
     (interactive)
     (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))
#+END_SRC
*** Minibuffer
This code comes from [[http://www.emacswiki.org/emacs/MiniBuffer][EmacsWiki]].

#+BEGIN_SRC emacs-lisp
  (defun switch-to-minibuffer ()
    "Switch to minibuffer window."
    (interactive)
    (if (active-minibuffer-window)
        (select-window (active-minibuffer-window))
      (error "Minibuffer is not active")))
  
  (bind-key "M-m" 'switch-to-minibuffer)
#+END_SRC
** Edit as Root
This tip comes from an [[http://emacs-fu.blogspot.kr/2013/03/editing-with-root-privileges-once-more.html][emacs-fu blog post]].

#+BEGIN_SRC emacs-lisp
  (defun find-file-as-root ()
    "Like `ido-find-file, but automatically edit the file with
  root-privileges (using tramp/sudo), if the file is not writable by
  user."
    (interactive)
    (let ((file (ido-read-file-name "Edit as root: ")))
      (unless (file-writable-p file)
        (setq file (concat "/sudo:root@localhost:" file)))
      (find-file file)))
  
  (bind-key "C-x F" 'find-file-as-root)
#+END_SRC
** Unfill Paragraph
This function greedily borrowed from Sacha.

#+BEGIN_SRC emacs-lisp
  (defun unfill-paragraph (&optional region)
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive (progn
                   (barf-if-buffer-read-only)
                   (list t)))
    (let ((fill-column (point-max)))
      (fill-paragraph nil region)))
  
  (bind-key "M-Q" 'unfill-paragraph)
#+END_SRC
** Org Go To Heading
Speed commands are really useful, but I often want to make use of them when I'm not at the beginning of a header. This command brings you back to the beginning of an item's header, so that you can do speed commands.

#+BEGIN_SRC emacs-lisp
  (defun org-go-speed ()
    "Goes to the beginning of an element's header, so that you can execute speed commands."
    (interactive)
    (when (equal major-mode 'org-mode)
      (if (org-at-heading-p)
          (org-beginning-of-line)
        (org-up-element))))
  
  (bind-key "C-c s" 'org-go-speed)
#+END_SRC
** Hide Mode Line
I wonder if Will Mengarini would approve of [[http://bzg.fr/emacs-hide-mode-line.html][Bastien's post]]... I know I need all the space I can get on this laptop!

#+BEGIN_SRC emacs-lisp
  (defvar-local hidden-mode-line-mode nil)
  
  (define-minor-mode hidden-mode-line-mode
    "Minor mode to hide the mode-line in the current buffer."
    :init-value nil
    :global t
    :variable hidden-mode-line-mode
    :group 'editing-basics
    (if hidden-mode-line-mode
        (setq hide-mode-line mode-line-format
              mode-line-format nil)
      (setq mode-line-format hide-mode-line
            hide-mode-line nil))
    (force-mode-line-update)
    ;; Apparently force-mode-line-update is not always enough to
    ;; redisplay the mode-line
    (redraw-display)
    (when (and (called-interactively-p 'interactive)
               hidden-mode-line-mode)
      (run-with-idle-timer
       0 nil 'message
       (concat "Hidden Mode Line Mode enabled.  "
               "Use M-x hidden-mode-line-mode to make the mode-line appear."))))
  
  (bind-key "m" 'hidden-mode-line-mode toggle-map)
#+END_SRC
** Narrowing and Widening
Before this function, I was alternating between C-x n s (org-narrow-to-subtree) and C-x n w (widen) in Org files. I originally implemented this to [[http://endlessparentheses.com/the-toggle-map-and-wizardry.html][toggle]] between those two cases as well as the region. [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][Artur Malabarba and Sacha Chua]] have made successive improvements: a prefix argument to narrow no matter what, and increasing features for Org.

#+BEGIN_SRC emacs-lisp
  (defun narrow-or-widen-dwim (p)
    "If the buffer is narrowed, it widens. Otherwise, it narrows
  intelligently.  Intelligently means: region, org-src-block,
  org-subtree, or defun, whichever applies first.  Narrowing to
  org-src-block actually calls `org-edit-src-code'.
  
  With prefix P, don't widen, just narrow even if buffer is already
  narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((and (boundp 'org-src-mode) org-src-mode (not p))
           (org-edit-src-exit))
          ((region-active-p)
           (narrow-to-region (region-beginning) (region-end)))
          ((derived-mode-p 'org-mode)
           (cond ((ignore-errors (org-edit-src-code))
                  (delete-other-windows))
                 ((org-at-block-p)
                  (org-narrow-to-block))
                 (t (org-narrow-to-subtree))))
          ((derived-mode-p 'prog-mode) (narrow-to-defun))
          (t (error "Please select a region to narrow to"))))
  
  (bind-key "n" 'narrow-or-widen-dwim toggle-map)
#+END_SRC
** Toggle Read Only
A lot of modes let you change from read-only to writeable, or backwards: files, Dired, and also wgrep-enabled modes. I use [[https://github.com/ggreer/the_silver_searcher][ag, the silver searcher]], instead of grep or ack. Anyways, this function decides which mode I am in and acts accordingly. That way, I need to remember just one key bind, C-x t r.

#+BEGIN_SRC emacs-lisp
  (defun read-write-toggle ()
    "Toggles read-only in any relevant mode: ag-mode, Dired, or
  just any file at all."
    (interactive)
    (if (equal major-mode 'ag-mode)
        ;; wgrep-ag can support ag-mode
        (wgrep-change-to-wgrep-mode)
      ;; dired-toggle-read-only has its own conditional:
      ;; if the mode is Dired, it will make the directory writable
      ;; if it is not, it will just toggle read only, as desired
      (dired-toggle-read-only)))
  
  (bind-key "r" 'read-write-toggle toggle-map)
#+END_SRC
** Move Lines
Via [[https://github.com/hrs/dotfiles][Harry Schwartz]].

#+BEGIN_SRC emacs-lisp
  (defun move-line-up ()
    (interactive)
    (transpose-lines 1)
    (forward-line -2))
  
  (defun move-line-down ()
    (interactive)
    (forward-line 1)
    (transpose-lines 1)
    (forward-line -1))
  
  (bind-key "M-<up>" 'move-line-up)
  (bind-key "M-<down>" 'move-line-down)
#+END_SRC
** Window Management
Via [[https://github.com/hrs/dotfiles][Harry Schwartz]].

#+BEGIN_SRC emacs-lisp
  (defun split-window-below-and-switch ()
    (interactive)
    (split-window-below)
    (other-window 1))
  
  (defun split-window-right-and-switch ()
    (interactive)
    (split-window-right)
    (other-window 1))
  
  (bind-key "C-x 2" 'split-window-below-and-switch)
  (bind-key "C-x 3" 'split-window-right-and-switch)
#+END_SRC
